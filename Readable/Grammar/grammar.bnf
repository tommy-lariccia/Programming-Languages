// GRAMMAR - Tommy Lariccia
// https://github.com/tommy-lariccia/Programming-Languages/tree/main/Readable


program ::= statement*

statement ::= progStatement comment?
            | comment
            | commentBlock

progStatement ::= functionDefinition lineEndChar
                | functionCall lineEndChar
                | variableInitializationAssignment lineEndChar
                | conditionalStatement
                | loopStatement lineEndChar
                | lambdaInitialization lineEndChar
                | returnStatement lineEndChar

blockStatement ::= blockProgStatement comment? lineEndChar
                 | comment lineEndChar
                 | commentBlock lineEndChar

blockProgStatement ::= functionCall lineEndChar
                     | variableInitializationAssignment lineEndChar
                     | conditionalStatement
                     | loopStatement lineEndChar
                     | lambdaInitialization lineEndChar
                     | returnStatement lineEndChar

lineEndChar ::= "\n" | "\r" | EOF


// COMMENTS
comment ::= "//" (!"\n")*  // anything but newline character

commentBlock ::= "/*" (!"*\\")* "*\\"


// TYPES
booleanOpts ::= "true" | "false"

typing ::= typingArr | typingKeywords

typingArr ::= typingKeywords"[]"

typingKeywords ::= "int" | "str" | "bool" | "float"


// VARIABLES
variableInitializationAssignment ::= assignment | arrSlotAssign

assignment ::= assignmentPrefix? IDENTIFIER "=" expression

assignmentPrefix ::= "local" | typing  // mutually exclusive, local only for dynamic variables

arrSlotAssign ::= typingArr? arrAccess "=" expression  // TODO: Typing required?

arr ::= "[" exprList? "]"

arrAccess ::= IDENTIFIER "[" expression "]"

exprList ::= expression
            | expression "," exprList


// EXPRESSIONS
expression ::= binaryExpression

binaryExpression ::= unaryExpression binaryOp binaryExpression
                   | unaryExpression

binaryOp ::= '*' | '/' | '+' | '-' | "and" | "or" | "==" | ">" | "<" | ">=" | "<="

unaryExpression ::= frontUnaryExpression | terminalExpression  // no use for combining unaries

frontUnaryExpression ::= frontUnaryOperator terminalExpression

frontUnaryOperator ::= "-" | "!"

parenExpression ::= "(" expression ")"

terminalExpression ::= functionCall | INT_LIT | FLOAT_LIT | IDENTIFIER | STRING_LIT | parenExpression | booleanOpts |
                       arr | arrAccess | "null"


// BLOCKS
block ::= blockStart blockSpace

blockStart ::= ":" lineEndChar

blockSpace ::= QUADSPACE blockStatement
        | QUADSPACE blockStatement lineEndChar blockSpace

// FUNCTIONS
functionCall ::= IDENTIFIER "(" argList? ")"

argList ::= expression
          | expression "," argList

paramList ::= parameter
            | parameter "," paramList

parameter ::= typing? IDENTIFIER

returnStatement ::= "return" expression

functionDefinition ::= "func" typing? IDENTIFIER "(" paramList? ")" block

lambdaInitialization ::= "lambda" IDENTIFIER "=" "(" paramList? ")" "=>" expression


// LOOPS
loopStatement ::= whileLoop | forEachLoop

whileLoop ::= "while" expression block

forEachLoop ::= "foreach" IDENTIFIER "in" iterable block

iterable ::= arr | INT_LIT | range

range ::= INT_LIT".."INT_LIT


// CONDITIONALS
conditionalStatement ::= ifBlock elifBlock* elseBlock?

ifBlock ::= "if" expression block

elifBlock ::= "else" "if" expression block

elseBlock ::= "else" expression block